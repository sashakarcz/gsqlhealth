//line /home/sasha/gsqlhealth/internal/health/scheduler.go:1:1
package health

import (
	"context"
	"log/slog"
	"sync"
	"time"

	"gsqlhealth/internal/database"
)

// ScheduledCheck represents a scheduled health check task
type ScheduledCheck struct {
	DatabaseName string
	TableName    string
	Interval     time.Duration
	ticker       *time.Ticker
	stopCh       chan bool
}

// Scheduler manages periodic health checks
type Scheduler struct {
	service     *Service
	logger      *slog.Logger
	checks      map[string]*ScheduledCheck // key: "database/table"
	results     map[string]*CachedResult   // key: "database/table"
	mu          sync.RWMutex
	ctx         context.Context
	cancel      context.CancelFunc
}

// CachedResult holds a cached health check result with timestamp
type CachedResult struct {
	Result    *database.HealthResult
	Error     error
	UpdatedAt time.Time
	mu        sync.RWMutex
}

// NewScheduler creates a new health check scheduler
func NewScheduler(service *Service, logger *slog.Logger) *Scheduler {goCover_507e7b9a9a2c__16[0] = 1 ; goCover_507e7b9a9a2c__16[1] = goCover_507e7b9a9a2c_P ; goCover_507e7b9a9a2c__16[2] = 16 ; goCover_507e7b9a9a2c__16[3] = 1;
	ctx, cancel := context.WithCancel(context.Background())
	return &Scheduler{
		service: service,
		logger:  logger,
		checks:  make(map[string]*ScheduledCheck),
		results: make(map[string]*CachedResult),
		ctx:     ctx,
		cancel:  cancel,
	}
}

// Start initializes and starts all scheduled health checks
func (s *Scheduler) Start() error {goCover_507e7b9a9a2c__17[0] = 4 ; goCover_507e7b9a9a2c__17[1] = goCover_507e7b9a9a2c_P ; goCover_507e7b9a9a2c__17[2] = 17 ; goCover_507e7b9a9a2c__17[3] = 1;
	s.mu.Lock()
	defer s.mu.Unlock()

	s.logger.Info("Starting health check scheduler")

	// Create scheduled checks for all configured tables
	for _, dbConfig := range s.service.config.Databases {goCover_507e7b9a9a2c__17[5] = 1;
		for _, tableConfig := range dbConfig.Tables {goCover_507e7b9a9a2c__17[6] = 1;
			key := s.getCheckKey(dbConfig.Name, tableConfig.Name)

			scheduledCheck := &ScheduledCheck{
				DatabaseName: dbConfig.Name,
				TableName:    tableConfig.Name,
				Interval:     tableConfig.GetCheckInterval(),
				stopCh:       make(chan bool, 1),
			}

			s.checks[key] = scheduledCheck
			s.results[key] = &CachedResult{
				UpdatedAt: time.Now(),
			}

			// Start the periodic check
			go s.runPeriodicCheck(scheduledCheck)

			s.logger.Info("Scheduled health check",
				"database", dbConfig.Name,
				"table", tableConfig.Name,
				"interval", tableConfig.GetCheckInterval())
		}
	}

	goCover_507e7b9a9a2c__17[4] = 1;return nil
}

// Stop stops all scheduled health checks
func (s *Scheduler) Stop() {goCover_507e7b9a9a2c__18[0] = 7 ; goCover_507e7b9a9a2c__18[1] = goCover_507e7b9a9a2c_P ; goCover_507e7b9a9a2c__18[2] = 18 ; goCover_507e7b9a9a2c__18[3] = 1;
	s.mu.Lock()
	defer s.mu.Unlock()

	s.logger.Info("Stopping health check scheduler")

	// Stop all scheduled checks
	for _, check := range s.checks {goCover_507e7b9a9a2c__18[5] = 1;
		if check.ticker != nil {goCover_507e7b9a9a2c__18[7] = 1;
			check.ticker.Stop()
		}
		goCover_507e7b9a9a2c__18[6] = 1;select {
		case check.stopCh <- true:goCover_507e7b9a9a2c__18[8] = 1;
		default:goCover_507e7b9a9a2c__18[9] = 1;
		}
	}

	// Cancel the context
	goCover_507e7b9a9a2c__18[4] = 1;s.cancel()

	s.logger.Info("Health check scheduler stopped")
}

// runPeriodicCheck runs a periodic health check for a specific database/table
func (s *Scheduler) runPeriodicCheck(check *ScheduledCheck) {goCover_507e7b9a9a2c__19[0] = 5 ; goCover_507e7b9a9a2c__19[1] = goCover_507e7b9a9a2c_P ; goCover_507e7b9a9a2c__19[2] = 19 ; goCover_507e7b9a9a2c__19[3] = 1;
	key := s.getCheckKey(check.DatabaseName, check.TableName)

	// Perform initial check
	s.performHealthCheck(check.DatabaseName, check.TableName, key)

	// Set up ticker for periodic checks
	check.ticker = time.NewTicker(check.Interval)
	defer check.ticker.Stop()

	for {goCover_507e7b9a9a2c__19[4] = 1;
		select {
		case <-check.ticker.C:goCover_507e7b9a9a2c__19[5] = 1;
			s.performHealthCheck(check.DatabaseName, check.TableName, key)
		case <-check.stopCh:goCover_507e7b9a9a2c__19[6] = 1;
			s.logger.Debug("Stopping scheduled check",
				"database", check.DatabaseName,
				"table", check.TableName)
			return
		case <-s.ctx.Done():goCover_507e7b9a9a2c__19[7] = 1;
			return
		}
	}
}

// performHealthCheck executes a health check and updates the cached result
func (s *Scheduler) performHealthCheck(databaseName, tableName, key string) {goCover_507e7b9a9a2c__20[0] = 4 ; goCover_507e7b9a9a2c__20[1] = goCover_507e7b9a9a2c_P ; goCover_507e7b9a9a2c__20[2] = 20 ; goCover_507e7b9a9a2c__20[3] = 1;
	ctx, cancel := context.WithTimeout(s.ctx, 30*time.Second)
	defer cancel()

	s.logger.Debug("Performing scheduled health check",
		"database", databaseName,
		"table", tableName)

	result, err := s.service.CheckHealth(ctx, databaseName, tableName)

	// Update cached result
	s.mu.RLock()
	cachedResult, exists := s.results[key]
	s.mu.RUnlock()

	if exists {goCover_507e7b9a9a2c__20[4] = 1;
		cachedResult.mu.Lock()
		cachedResult.Result = result
		cachedResult.Error = err
		cachedResult.UpdatedAt = time.Now()
		cachedResult.mu.Unlock()

		if err != nil {goCover_507e7b9a9a2c__20[5] = 1;
			s.logger.Debug("Scheduled health check failed (expected during startup/outages)",
				"database", databaseName,
				"table", tableName,
				"error", err)
		} else{ goCover_507e7b9a9a2c__20[6] = 1;{
			s.logger.Debug("Scheduled health check completed",
				"database", databaseName,
				"table", tableName,
				"status", result.Status)
		}}
	}
}

// GetCachedResult returns the cached result for a specific database/table
func (s *Scheduler) GetCachedResult(databaseName, tableName string) (*database.HealthResult, error, time.Time) {goCover_507e7b9a9a2c__21[0] = 3 ; goCover_507e7b9a9a2c__21[1] = goCover_507e7b9a9a2c_P ; goCover_507e7b9a9a2c__21[2] = 21 ; goCover_507e7b9a9a2c__21[3] = 1;
	key := s.getCheckKey(databaseName, tableName)

	s.mu.RLock()
	cachedResult, exists := s.results[key]
	s.mu.RUnlock()

	if !exists {goCover_507e7b9a9a2c__21[5] = 1;
		return nil, NewNotFoundError(databaseName, tableName, "no cached result available"), time.Time{}
	}

	goCover_507e7b9a9a2c__21[4] = 1;cachedResult.mu.RLock()
	defer cachedResult.mu.RUnlock()

	return cachedResult.Result, cachedResult.Error, cachedResult.UpdatedAt
}

// GetCachedDatabaseResults returns cached results for all tables in a database
func (s *Scheduler) GetCachedDatabaseResults(databaseName string) ([]*database.HealthResult, error) {goCover_507e7b9a9a2c__22[0] = 10 ; goCover_507e7b9a9a2c__22[1] = goCover_507e7b9a9a2c_P ; goCover_507e7b9a9a2c__22[2] = 22 ; goCover_507e7b9a9a2c__22[3] = 1;
	s.mu.RLock()
	defer s.mu.RUnlock()

	var results []*database.HealthResult
	found := false

	for key, cachedResult := range s.results {goCover_507e7b9a9a2c__22[6] = 1;
		if s.checkKeyMatches(key, databaseName, "") {goCover_507e7b9a9a2c__22[7] = 1;
			found = true
			cachedResult.mu.RLock()
			if cachedResult.Result != nil {goCover_507e7b9a9a2c__22[9] = 1;
				results = append(results, cachedResult.Result)
			} else{ goCover_507e7b9a9a2c__22[10] = 1;if cachedResult.Error != nil {goCover_507e7b9a9a2c__22[11] = 1;
				// Create error result
				_, tableName := s.parseCheckKey(key)
				errorResult := &database.HealthResult{
					DatabaseName: databaseName,
					TableName:    tableName,
					Status:       "error",
					Error:        cachedResult.Error.Error(),
					Timestamp:    cachedResult.UpdatedAt,
				}
				results = append(results, errorResult)
			}}
			goCover_507e7b9a9a2c__22[8] = 1;cachedResult.mu.RUnlock()
		}
	}

	goCover_507e7b9a9a2c__22[4] = 1;if !found {goCover_507e7b9a9a2c__22[12] = 1;
		return nil, NewNotFoundError(databaseName, "", "database not found in configuration")
	}

	goCover_507e7b9a9a2c__22[5] = 1;return results, nil
}

// GetAllCachedResults returns all cached health check results
func (s *Scheduler) GetAllCachedResults() map[string][]*database.HealthResult {goCover_507e7b9a9a2c__23[0] = 7 ; goCover_507e7b9a9a2c__23[1] = goCover_507e7b9a9a2c_P ; goCover_507e7b9a9a2c__23[2] = 23 ; goCover_507e7b9a9a2c__23[3] = 1;
	s.mu.RLock()
	defer s.mu.RUnlock()

	results := make(map[string][]*database.HealthResult)

	for key, cachedResult := range s.results {goCover_507e7b9a9a2c__23[5] = 1;
		databaseName, _ := s.parseCheckKey(key)

		cachedResult.mu.RLock()
		if cachedResult.Result != nil {goCover_507e7b9a9a2c__23[7] = 1;
			results[databaseName] = append(results[databaseName], cachedResult.Result)
		} else{ goCover_507e7b9a9a2c__23[8] = 1;if cachedResult.Error != nil {goCover_507e7b9a9a2c__23[9] = 1;
			// Create error result
			_, tableName := s.parseCheckKey(key)
			errorResult := &database.HealthResult{
				DatabaseName: databaseName,
				TableName:    tableName,
				Status:       "error",
				Error:        cachedResult.Error.Error(),
				Timestamp:    cachedResult.UpdatedAt,
			}
			results[databaseName] = append(results[databaseName], errorResult)
		}}
		goCover_507e7b9a9a2c__23[6] = 1;cachedResult.mu.RUnlock()
	}

	goCover_507e7b9a9a2c__23[4] = 1;return results
}

// IsResultFresh checks if a cached result is still fresh (within the check interval)
func (s *Scheduler) IsResultFresh(databaseName, tableName string) bool {goCover_507e7b9a9a2c__24[0] = 3 ; goCover_507e7b9a9a2c__24[1] = goCover_507e7b9a9a2c_P ; goCover_507e7b9a9a2c__24[2] = 24 ; goCover_507e7b9a9a2c__24[3] = 1;
	key := s.getCheckKey(databaseName, tableName)

	s.mu.RLock()
	check, checkExists := s.checks[key]
	cachedResult, resultExists := s.results[key]
	s.mu.RUnlock()

	if !checkExists || !resultExists {goCover_507e7b9a9a2c__24[5] = 1;
		return false
	}

	goCover_507e7b9a9a2c__24[4] = 1;cachedResult.mu.RLock()
	updatedAt := cachedResult.UpdatedAt
	cachedResult.mu.RUnlock()

	// Consider result fresh if it's within the check interval
	return time.Since(updatedAt) < check.Interval
}

// getCheckKey creates a unique key for a database/table combination
func (s *Scheduler) getCheckKey(databaseName, tableName string) string {goCover_507e7b9a9a2c__25[0] = 1 ; goCover_507e7b9a9a2c__25[1] = goCover_507e7b9a9a2c_P ; goCover_507e7b9a9a2c__25[2] = 25 ; goCover_507e7b9a9a2c__25[3] = 1;
	return databaseName + "/" + tableName
}

// parseCheckKey parses a check key back into database and table names
func (s *Scheduler) parseCheckKey(key string) (string, string) {goCover_507e7b9a9a2c__26[0] = 5 ; goCover_507e7b9a9a2c__26[1] = goCover_507e7b9a9a2c_P ; goCover_507e7b9a9a2c__26[2] = 26 ; goCover_507e7b9a9a2c__26[3] = 1;
	parts := make([]string, 2)
	if idx := len(key); idx > 0 {goCover_507e7b9a9a2c__26[5] = 1;
		for i, char := range key {goCover_507e7b9a9a2c__26[6] = 1;
			if char == '/' {goCover_507e7b9a9a2c__26[7] = 1;
				parts[0] = key[:i]
				parts[1] = key[i+1:]
				break
			}
		}
	}
	goCover_507e7b9a9a2c__26[4] = 1;return parts[0], parts[1]
}

// checkKeyMatches checks if a key matches database and table criteria
func (s *Scheduler) checkKeyMatches(key, databaseName, tableName string) bool {goCover_507e7b9a9a2c__27[0] = 5 ; goCover_507e7b9a9a2c__27[1] = goCover_507e7b9a9a2c_P ; goCover_507e7b9a9a2c__27[2] = 27 ; goCover_507e7b9a9a2c__27[3] = 1;
	db, table := s.parseCheckKey(key)

	if db != databaseName {goCover_507e7b9a9a2c__27[6] = 1;
		return false
	}

	goCover_507e7b9a9a2c__27[4] = 1;if tableName != "" && table != tableName {goCover_507e7b9a9a2c__27[7] = 1;
		return false
	}

	goCover_507e7b9a9a2c__27[5] = 1;return true
}

// GetCacheStats returns statistics about the cached results
func (s *Scheduler) GetCacheStats() map[string]interface{} {goCover_507e7b9a9a2c__28[0] = 8 ; goCover_507e7b9a9a2c__28[1] = goCover_507e7b9a9a2c_P ; goCover_507e7b9a9a2c__28[2] = 28 ; goCover_507e7b9a9a2c__28[3] = 1;
	s.mu.RLock()
	defer s.mu.RUnlock()

	totalChecks := len(s.results)
	freshResults := 0
	healthyResults := 0
	unhealthyResults := 0

	for key, cachedResult := range s.results {goCover_507e7b9a9a2c__28[5] = 1;
		cachedResult.mu.RLock()
		if cachedResult.Result != nil {goCover_507e7b9a9a2c__28[7] = 1;
			if cachedResult.Result.Status == "healthy" {goCover_507e7b9a9a2c__28[8] = 1;
				healthyResults++
			} else{ goCover_507e7b9a9a2c__28[9] = 1;{
				unhealthyResults++
			}}
		}
		goCover_507e7b9a9a2c__28[6] = 1;cachedResult.mu.RUnlock()

		databaseName, tableName := s.parseCheckKey(key)
		if s.IsResultFresh(databaseName, tableName) {goCover_507e7b9a9a2c__28[10] = 1;
			freshResults++
		}
	}

	goCover_507e7b9a9a2c__28[4] = 1;return map[string]interface{}{
		"total_checks":     totalChecks,
		"fresh_results":    freshResults,
		"healthy_results":  healthyResults,
		"unhealthy_results": unhealthyResults,
	}
}