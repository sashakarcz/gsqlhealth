//line /home/sasha/gsqlhealth/internal/health/retry.go:1:1
package health

import (
	"context"
	"fmt"
	"log/slog"
	"time"

	"gsqlhealth/internal/config"
	"gsqlhealth/internal/database"
)

// RetryableConnector handles connection attempts with retry logic
type RetryableConnector struct {
	config    *config.Retry
	logger    *slog.Logger
}

// NewRetryableConnector creates a new retryable connector
func NewRetryableConnector(retryConfig *config.Retry, logger *slog.Logger) *RetryableConnector {goCover_507e7b9a9a2c__10[0] = 1 ; goCover_507e7b9a9a2c__10[1] = goCover_507e7b9a9a2c_P ; goCover_507e7b9a9a2c__10[2] = 10 ; goCover_507e7b9a9a2c__10[3] = 1;
	return &RetryableConnector{
		config: retryConfig,
		logger: logger,
	}
}

// ConnectWithRetry attempts to connect to a database with retry logic
func (r *RetryableConnector) ConnectWithRetry(ctx context.Context, driver database.Driver, connInfo database.ConnectionInfo, databaseName string) error {goCover_507e7b9a9a2c__11[0] = 9 ; goCover_507e7b9a9a2c__11[1] = goCover_507e7b9a9a2c_P ; goCover_507e7b9a9a2c__11[2] = 11 ; goCover_507e7b9a9a2c__11[3] = 1;
	var lastError error
	delay := r.config.GetInitialDelay()
	attempt := 1

	for {goCover_507e7b9a9a2c__11[4] = 1;
		// Attempt connection
		r.logger.Info("Attempting database connection",
			"database", databaseName,
			"attempt", attempt,
			"delay", delay)

		err := driver.Connect(ctx, connInfo)
		if err == nil {goCover_507e7b9a9a2c__11[8] = 1;
			r.logger.Info("Successfully connected to database",
				"database", databaseName,
				"attempt", attempt)
			return nil
		}

		goCover_507e7b9a9a2c__11[5] = 1;lastError = err
		r.logger.Warn("Database connection failed, will retry",
			"database", databaseName,
			"attempt", attempt,
			"error", err,
			"next_retry_in", delay)

		// Check if we should stop retrying
		if r.config.MaxAttempts > 0 && attempt >= r.config.MaxAttempts {goCover_507e7b9a9a2c__11[9] = 1;
			r.logger.Error("Max connection attempts reached",
				"database", databaseName,
				"max_attempts", r.config.MaxAttempts,
				"last_error", lastError)
			return fmt.Errorf("failed to connect after %d attempts: %w", attempt, lastError)
		}

		// Wait before next attempt (with context cancellation support)
		goCover_507e7b9a9a2c__11[6] = 1;select {
		case <-time.After(delay):goCover_507e7b9a9a2c__11[10] = 1;
			// Continue to next attempt
		case <-ctx.Done():goCover_507e7b9a9a2c__11[11] = 1;
			r.logger.Info("Connection retry cancelled",
				"database", databaseName,
				"attempt", attempt)
			return ctx.Err()
		}

		// Calculate next delay with exponential backoff
		goCover_507e7b9a9a2c__11[7] = 1;delay = r.calculateNextDelay(delay)
		attempt++
	}
}

// calculateNextDelay calculates the next retry delay with exponential backoff
func (r *RetryableConnector) calculateNextDelay(currentDelay time.Duration) time.Duration {goCover_507e7b9a9a2c__12[0] = 3 ; goCover_507e7b9a9a2c__12[1] = goCover_507e7b9a9a2c_P ; goCover_507e7b9a9a2c__12[2] = 12 ; goCover_507e7b9a9a2c__12[3] = 1;
	nextDelay := time.Duration(float64(currentDelay) * float64(r.config.BackoffFactor))

	maxDelay := r.config.GetMaxDelay()
	if nextDelay > maxDelay {goCover_507e7b9a9a2c__12[5] = 1;
		nextDelay = maxDelay
	}

	goCover_507e7b9a9a2c__12[4] = 1;return nextDelay
}

// BackgroundConnectionRecovery runs background connection recovery for failed databases
func (s *Service) BackgroundConnectionRecovery(ctx context.Context) {goCover_507e7b9a9a2c__13[0] = 4 ; goCover_507e7b9a9a2c__13[1] = goCover_507e7b9a9a2c_P ; goCover_507e7b9a9a2c__13[2] = 13 ; goCover_507e7b9a9a2c__13[3] = 1;
	ticker := time.NewTicker(s.config.Retry.GetConnectionRetry())
	defer ticker.Stop()

	s.logger.Info("Starting background connection recovery",
		"retry_interval", s.config.Retry.GetConnectionRetry())

	for {goCover_507e7b9a9a2c__13[4] = 1;
		select {
		case <-ticker.C:goCover_507e7b9a9a2c__13[5] = 1;
			s.attemptConnectionRecovery(ctx)
		case <-ctx.Done():goCover_507e7b9a9a2c__13[6] = 1;
			s.logger.Info("Background connection recovery stopped")
			return
		}
	}
}

// attemptConnectionRecovery attempts to reconnect to failed databases
func (s *Service) attemptConnectionRecovery(ctx context.Context) {goCover_507e7b9a9a2c__14[0] = 10 ; goCover_507e7b9a9a2c__14[1] = goCover_507e7b9a9a2c_P ; goCover_507e7b9a9a2c__14[2] = 14 ; goCover_507e7b9a9a2c__14[3] = 1;
	s.mu.Lock()
	defer s.mu.Unlock()

	for _, dbConfig := range s.config.Databases {goCover_507e7b9a9a2c__14[4] = 1;
		// Check if this database is already connected
		if driver, exists := s.drivers[dbConfig.Name]; exists {goCover_507e7b9a9a2c__14[7] = 1;
			// Test if connection is still alive
			pingCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
			if err := driver.Ping(pingCtx); err == nil {goCover_507e7b9a9a2c__14[9] = 1;
				cancel()
				continue // Connection is healthy
			}
			goCover_507e7b9a9a2c__14[8] = 1;cancel()

			// Connection is dead, remove it
			s.logger.Warn("Database connection is dead, attempting recovery",
				"database", dbConfig.Name)
			driver.Close()
			delete(s.drivers, dbConfig.Name)
		}

		// Attempt to reconnect
		goCover_507e7b9a9a2c__14[5] = 1;s.logger.Info("Attempting database recovery",
			"database", dbConfig.Name)

		driver, err := s.factory.CreateDriver(dbConfig.Type)
		if err != nil {goCover_507e7b9a9a2c__14[10] = 1;
			s.logger.Error("Failed to create driver for recovery",
				"database", dbConfig.Name,
				"error", err)
			continue
		}

		goCover_507e7b9a9a2c__14[6] = 1;connInfo := database.ConnectionInfo{
			Host:     dbConfig.Host,
			Port:     dbConfig.Port,
			Username: dbConfig.Username,
			Password: dbConfig.Password,
			Database: dbConfig.Database,
			SSLMode:  dbConfig.SSLMode,
			Timeout:  30 * time.Second,
		}

		// Use single attempt for recovery (don't block the recovery loop)
		connCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
		err = driver.Connect(connCtx, connInfo)
		cancel()

		if err == nil {goCover_507e7b9a9a2c__14[11] = 1;
			s.drivers[dbConfig.Name] = driver
			s.logger.Info("Database connection recovered",
				"database", dbConfig.Name)
		} else{ goCover_507e7b9a9a2c__14[12] = 1;{
			s.logger.Debug("Database recovery failed, will try again later",
				"database", dbConfig.Name,
				"error", err)
			driver.Close()
		}}
	}
}

// IsConnected checks if a database is currently connected
func (s *Service) IsConnected(databaseName string) bool {goCover_507e7b9a9a2c__15[0] = 3 ; goCover_507e7b9a9a2c__15[1] = goCover_507e7b9a9a2c_P ; goCover_507e7b9a9a2c__15[2] = 15 ; goCover_507e7b9a9a2c__15[3] = 1;
	s.mu.RLock()
	defer s.mu.RUnlock()

	driver, exists := s.drivers[databaseName]
	if !exists {goCover_507e7b9a9a2c__15[5] = 1;
		return false
	}

	// Quick ping test
	goCover_507e7b9a9a2c__15[4] = 1;ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
	defer cancel()

	return driver.Ping(ctx) == nil
}