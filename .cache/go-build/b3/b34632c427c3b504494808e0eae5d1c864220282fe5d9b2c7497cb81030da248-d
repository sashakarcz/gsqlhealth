//line /home/sasha/gsqlhealth/internal/database/mssql.go:1:1
package database

import (
	"context"
	"database/sql"
	"fmt"
	"net/url"
	"strconv"
	"strings"
	"time"

	_ "github.com/microsoft/go-mssqldb"
)

// MSSQLDriver implements the Driver interface for Microsoft SQL Server databases
type MSSQLDriver struct {
	db *sql.DB
}

// NewMSSQLDriver creates a new MS SQL Server driver instance
func NewMSSQLDriver() *MSSQLDriver {goCover_d9c7f9aa98b6__6[0] = 1 ; goCover_d9c7f9aa98b6__6[1] = goCover_d9c7f9aa98b6_P ; goCover_d9c7f9aa98b6__6[2] = 6 ; goCover_d9c7f9aa98b6__6[3] = 1;
	return &MSSQLDriver{}
}

// Connect establishes a connection to the MS SQL Server database
func (d *MSSQLDriver) Connect(ctx context.Context, info ConnectionInfo) error {goCover_d9c7f9aa98b6__7[0] = 5 ; goCover_d9c7f9aa98b6__7[1] = goCover_d9c7f9aa98b6_P ; goCover_d9c7f9aa98b6__7[2] = 7 ; goCover_d9c7f9aa98b6__7[3] = 1;
	dsn := d.buildDSN(info)

	var err error
	d.db, err = sql.Open("sqlserver", dsn)
	if err != nil {goCover_d9c7f9aa98b6__7[6] = 1;
		return fmt.Errorf("failed to open MS SQL Server connection: %w", err)
	}

	// Configure connection pool settings
	goCover_d9c7f9aa98b6__7[4] = 1;d.db.SetMaxOpenConns(25)
	d.db.SetMaxIdleConns(5)
	d.db.SetConnMaxLifetime(5 * time.Minute)
	d.db.SetConnMaxIdleTime(1 * time.Minute)

	// Test the connection
	ctx, cancel := context.WithTimeout(ctx, info.Timeout)
	defer cancel()

	if err := d.db.PingContext(ctx); err != nil {goCover_d9c7f9aa98b6__7[7] = 1;
		d.db.Close()
		return fmt.Errorf("failed to ping MS SQL Server database: %w", err)
	}

	goCover_d9c7f9aa98b6__7[5] = 1;return nil
}

// Close closes the MS SQL Server database connection
func (d *MSSQLDriver) Close() error {goCover_d9c7f9aa98b6__8[0] = 3 ; goCover_d9c7f9aa98b6__8[1] = goCover_d9c7f9aa98b6_P ; goCover_d9c7f9aa98b6__8[2] = 8 ; goCover_d9c7f9aa98b6__8[3] = 1;
	if d.db != nil {goCover_d9c7f9aa98b6__8[5] = 1;
		return d.db.Close()
	}
	goCover_d9c7f9aa98b6__8[4] = 1;return nil
}

// ExecuteHealthCheck executes a health check query and returns the results
func (d *MSSQLDriver) ExecuteHealthCheck(ctx context.Context, query string) (map[string]interface{}, error) {goCover_d9c7f9aa98b6__9[0] = 5 ; goCover_d9c7f9aa98b6__9[1] = goCover_d9c7f9aa98b6_P ; goCover_d9c7f9aa98b6__9[2] = 9 ; goCover_d9c7f9aa98b6__9[3] = 1;
	if d.db == nil {goCover_d9c7f9aa98b6__9[6] = 1;
		return nil, fmt.Errorf("database connection is not established")
	}

	goCover_d9c7f9aa98b6__9[4] = 1;rows, err := d.db.QueryContext(ctx, query)
	if err != nil {goCover_d9c7f9aa98b6__9[7] = 1;
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	goCover_d9c7f9aa98b6__9[5] = 1;defer rows.Close()

	return d.processRows(rows)
}

// Ping tests the database connection
func (d *MSSQLDriver) Ping(ctx context.Context) error {goCover_d9c7f9aa98b6__10[0] = 3 ; goCover_d9c7f9aa98b6__10[1] = goCover_d9c7f9aa98b6_P ; goCover_d9c7f9aa98b6__10[2] = 10 ; goCover_d9c7f9aa98b6__10[3] = 1;
	if d.db == nil {goCover_d9c7f9aa98b6__10[5] = 1;
		return fmt.Errorf("database connection is not established")
	}
	goCover_d9c7f9aa98b6__10[4] = 1;return d.db.PingContext(ctx)
}

// GetDriverName returns the name of the database driver
func (d *MSSQLDriver) GetDriverName() string {goCover_d9c7f9aa98b6__11[0] = 1 ; goCover_d9c7f9aa98b6__11[1] = goCover_d9c7f9aa98b6_P ; goCover_d9c7f9aa98b6__11[2] = 11 ; goCover_d9c7f9aa98b6__11[3] = 1;
	return "mssql"
}

// buildDSN constructs the MS SQL Server data source name
func (d *MSSQLDriver) buildDSN(info ConnectionInfo) string {goCover_d9c7f9aa98b6__12[0] = 11 ; goCover_d9c7f9aa98b6__12[1] = goCover_d9c7f9aa98b6_P ; goCover_d9c7f9aa98b6__12[2] = 12 ; goCover_d9c7f9aa98b6__12[3] = 1;
	query := url.Values{}

	// Set database name
	query.Add("database", info.Database)

	// Set connection timeout
	if info.Timeout > 0 {goCover_d9c7f9aa98b6__12[6] = 1;
		timeoutSeconds := int(info.Timeout.Seconds())
		query.Add("connection timeout", strconv.Itoa(timeoutSeconds))
		query.Add("dial timeout", strconv.Itoa(timeoutSeconds))
	}

	// Set application name for easier identification
	goCover_d9c7f9aa98b6__12[4] = 1;query.Add("app name", "gsqlhealth")

	// Enable encryption based on SSL mode
	if info.SSLMode != "" {goCover_d9c7f9aa98b6__12[7] = 1;
		switch strings.ToLower(info.SSLMode) {
		case "disable", "false":goCover_d9c7f9aa98b6__12[8] = 1;
			query.Add("encrypt", "disable")
		case "require", "true":goCover_d9c7f9aa98b6__12[9] = 1;
			query.Add("encrypt", "true")
			query.Add("trustservercertificate", "true")
		case "verify-ca":goCover_d9c7f9aa98b6__12[10] = 1;
			query.Add("encrypt", "true")
			query.Add("trustservercertificate", "false")
		case "verify-full":goCover_d9c7f9aa98b6__12[11] = 1;
			query.Add("encrypt", "true")
			query.Add("trustservercertificate", "false")
			query.Add("hostnameincertificate", info.Host)
		default:goCover_d9c7f9aa98b6__12[12] = 1;
			query.Add("encrypt", "true")
			query.Add("trustservercertificate", "true")
		}
	} else{ goCover_d9c7f9aa98b6__12[13] = 1;{
		// Default to encrypted connection with trusted certificate
		query.Add("encrypt", "true")
		query.Add("trustservercertificate", "true")
	}}

	// Build the connection URL
	goCover_d9c7f9aa98b6__12[5] = 1;u := &url.URL{
		Scheme:   "sqlserver",
		User:     url.UserPassword(info.Username, info.Password),
		Host:     fmt.Sprintf("%s:%d", info.Host, info.Port),
		RawQuery: query.Encode(),
	}

	return u.String()
}

// processRows processes SQL query results and returns them as a map
func (d *MSSQLDriver) processRows(rows *sql.Rows) (map[string]interface{}, error) {goCover_d9c7f9aa98b6__13[0] = 20 ; goCover_d9c7f9aa98b6__13[1] = goCover_d9c7f9aa98b6_P ; goCover_d9c7f9aa98b6__13[2] = 13 ; goCover_d9c7f9aa98b6__13[3] = 1;
	columns, err := rows.Columns()
	if err != nil {goCover_d9c7f9aa98b6__13[9] = 1;
		return nil, fmt.Errorf("failed to get column names: %w", err)
	}

	goCover_d9c7f9aa98b6__13[4] = 1;columnTypes, err := rows.ColumnTypes()
	if err != nil {goCover_d9c7f9aa98b6__13[10] = 1;
		return nil, fmt.Errorf("failed to get column types: %w", err)
	}

	goCover_d9c7f9aa98b6__13[5] = 1;result := make(map[string]interface{})

	// If we have multiple rows, collect them in an array
	var allResults []map[string]interface{}

	for rows.Next() {goCover_d9c7f9aa98b6__13[11] = 1;
		// Create a slice of interface{} to hold the values
		values := make([]interface{}, len(columns))
		valuePtrs := make([]interface{}, len(columns))

		// Create pointers to the values
		for i := range values {goCover_d9c7f9aa98b6__13[15] = 1;
			valuePtrs[i] = &values[i]
		}

		// Scan the values
		goCover_d9c7f9aa98b6__13[12] = 1;if err := rows.Scan(valuePtrs...); err != nil {goCover_d9c7f9aa98b6__13[16] = 1;
			return nil, fmt.Errorf("failed to scan row: %w", err)
		}

		// Convert values to appropriate types
		goCover_d9c7f9aa98b6__13[13] = 1;rowResult := make(map[string]interface{})
		for i, col := range columns {goCover_d9c7f9aa98b6__13[17] = 1;
			rowResult[col] = d.convertValue(values[i], columnTypes[i])
		}

		goCover_d9c7f9aa98b6__13[14] = 1;allResults = append(allResults, rowResult)
	}

	goCover_d9c7f9aa98b6__13[6] = 1;if err := rows.Err(); err != nil {goCover_d9c7f9aa98b6__13[18] = 1;
		return nil, fmt.Errorf("error iterating over rows: %w", err)
	}

	// If we only have one row, return it directly
	// Otherwise, return all results
	goCover_d9c7f9aa98b6__13[7] = 1;if len(allResults) == 1 {goCover_d9c7f9aa98b6__13[19] = 1;
		result = allResults[0]
	} else{ goCover_d9c7f9aa98b6__13[20] = 1;if len(allResults) > 1 {goCover_d9c7f9aa98b6__13[21] = 1;
		result["results"] = allResults
		result["row_count"] = len(allResults)
	} else{ goCover_d9c7f9aa98b6__13[22] = 1;{
		result["row_count"] = 0
	}}}

	goCover_d9c7f9aa98b6__13[8] = 1;return result, nil
}

// convertValue converts a database value to an appropriate Go type
func (d *MSSQLDriver) convertValue(value interface{}, colType *sql.ColumnType) interface{} {goCover_d9c7f9aa98b6__14[0] = 16 ; goCover_d9c7f9aa98b6__14[1] = goCover_d9c7f9aa98b6_P ; goCover_d9c7f9aa98b6__14[2] = 14 ; goCover_d9c7f9aa98b6__14[3] = 1;
	if value == nil {goCover_d9c7f9aa98b6__14[8] = 1;
		return nil
	}

	// Handle byte arrays (common for VARBINARY, IMAGE, etc.)
	goCover_d9c7f9aa98b6__14[4] = 1;if byteVal, ok := value.([]byte); ok {goCover_d9c7f9aa98b6__14[9] = 1;
		// Try to convert to string if it's valid UTF-8
		str := string(byteVal)
		return str
	}

	// Handle time values
	goCover_d9c7f9aa98b6__14[5] = 1;if timeVal, ok := value.(time.Time); ok {goCover_d9c7f9aa98b6__14[10] = 1;
		return timeVal.Format(time.RFC3339)
	}

	// Handle MS SQL Server specific types
	goCover_d9c7f9aa98b6__14[6] = 1;switch colType.DatabaseTypeName() {
	case "UNIQUEIDENTIFIER":goCover_d9c7f9aa98b6__14[11] = 1;
		// Convert GUID to string
		if strVal, ok := value.(string); ok {goCover_d9c7f9aa98b6__14[15] = 1;
			return strings.ToUpper(strVal)
		}
	case "BIT":goCover_d9c7f9aa98b6__14[12] = 1;
		// Convert bit to boolean
		if intVal, ok := value.(int64); ok {goCover_d9c7f9aa98b6__14[16] = 1;
			return intVal != 0
		}
		goCover_d9c7f9aa98b6__14[13] = 1;if boolVal, ok := value.(bool); ok {goCover_d9c7f9aa98b6__14[17] = 1;
			return boolVal
		}
	case "DECIMAL", "NUMERIC", "MONEY", "SMALLMONEY":goCover_d9c7f9aa98b6__14[14] = 1;
		// These might come as strings from the driver
		if strVal, ok := value.(string); ok {goCover_d9c7f9aa98b6__14[18] = 1;
			return strVal
		}
	}

	goCover_d9c7f9aa98b6__14[7] = 1;return value
}